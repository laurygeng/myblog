### 网络  ###  


#### 当在浏览器中输入访问地址    并且按下  回车之后发生了什么？  ####

（1）解析URL：首先会对URL进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的URL中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查URL中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。  
（2）缓存判断： 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。  
（3）DNS解析： 下一步首先需要获取的是输入的URL中的域名的IP地址，首先会判断本地是否有该域名的IP地址的缓存，如果有则使用，如果没有则向本地DNS服务器发起请求。本地DNS服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的IP地址后，本地 DNS服务器再将这个IP地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地DNS服务器向各级域名服务器发起请求属于迭代请求。     
（4）获取MAC地址： 当浏览器得到IP地址后，数据传输还需要知道目的主机MAC地址，因为应用层下发数据给传输层，TCP协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的IP地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的MAC地址，本机的MAC地址作为源MAC地址，目的MAC地址需要分情况处理。通过将IP地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用APR协议获取到目的主机的MAC地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过ARP协议来获取网关的MAC地址，此时目的主机的MAC地址应该为网关的地址。  
（5）TCP三次握手：下面是TCP建立连接的三次握手的过程，首先客户端向服务器发送一个SYN连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。   
（6）HTTPS握手： 如果使用的是 HTTPS 协议，在  通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。  
（7）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。  
（8）页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。  
（9）TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。  


### HTTP和HTTPS协议的区别 ###
HTTP和HTTPS协议的主要区别如下：  

HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；  
HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；  
使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；  
HTTP协议连接很简单，是无状态的；HTT  PS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。  


### 与缓存相关的HTTP请求头有哪些 ###  
+ 强缓存：  
Expires  
Cache-Control：  
在Response Headers中,控制强制缓存的逻辑。例如 Cache-Control: max-age=3153600（单位是秒）

Cache-Control 有哪些值：
max-age：缓存最大过期时间。
no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。
no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。

+ 协商缓存：  
Etag、If-None-Match  
Last-Modified、If-Modified-Since  

在Response Headers中，有两种。
Last-Modified：资源的最后修改时间。   
Last-Modified 精确到秒级。服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。
Etag：资源的唯一标识（一个字符串，类似于人类的指纹）。   
Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。   

优先使用 Etag。如果资源被重复生成，而内容不变，则Etag更精确。   

为什么需要缓存？   
网络请求相比于CPU的计算和页面渲染是非常慢的，那些资源需要被缓存？静态资源，js，css，img
三种刷新操作对 http 缓存的影响
正常操作：地址栏输入 url，跳转链接，前进后退等。
手动刷新：f5，点击刷新按钮，右键菜单刷新。
强制刷新：ctrl + f5，shift+command+r。
正常操作：强制缓存有效，协商缓存有效。
手动刷新：强制缓存失效，协商缓存有效。
强制刷新：强制缓存失效，协商缓存失效。


### GET和POST的请求的区别 ### 
Post 和 Get 是 HTTP 请求的两种方法，其区别如下：

应用场景： GET 请求是一个幂等的请求(幂等表示执行相同的操作，结果也是相同的)，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。   
而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
是否缓存： 因为两者应用场景不同，浏览器一般会对 Get 请求缓存  ，但很少对 Post 请求缓存。   
发送的报文格式： Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
安全性： Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
参数类型： post 的参数传递支持更多的数据类型。

### 跨域 ###  
跨域，是指浏览器不能执行其它网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript实施的安全限制。   
所谓同源，就是域名、协议、端口均相同
http://abc.123.com/index.html 调用 http://xyz.123.com/server.do （子域名不同:abc/def，跨域）

### CORS ###  
CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）  
实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信
非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）     
同源策略影响了项目之间的连接，尤其是大项目，需要多个域名配合完成
CORS的基本思想就是使用额外的HTTP头部让浏览器与服务器进行沟通，从而决定是否接受跨域请求。

CORS与JSONP的使用目的相同，但是比JSONP更强大。  
JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。  
服务端解决方式：代理转发和配置CORS
增加代理服务器和资源服务器放在同一个域名下面，请求走代理服务器这样就是同源访问，不存在跨域的问题了
在目标服务器上配置CORS响应头，这样浏览器经过对比判断之后，就可以发起正常的访问。