### 模块化 ###  

模块化解决的问题是：全局变量污染，命名冲突，文件依赖

#### commonjs #### 
同步阻塞的方式，主要用于服务端Node.js,不会返回promise或者回调，输出的是值的copy，是运行时加载，只能是单个，是动态语法可以写在判断里，this是当前模块  
语法：require（）和module.exports 
在webpack打包的时候会解读这些语法，可以根据自己的实际需求来调整

例如，Vue项目在解析template时候, 会经过Webpack打包解析img标签, 如果src是静态字符串, 如果不是http开头的, 那么就是相对于源码目录的图片
那么如果把src设置为一个变量, 那么template里解析img标签的时候并不知道src的值, 是不是http开头的, 需要运行时才知道, 所以需要你告诉构建工具, 项目使用了这个图片资源, 然后返回相对于web服务器根目录的路径(dist目录也行)
require(‘xx.jpg’)的作用就是把图片复制到dist目录下的某个目录(根据你的配置), 然后返回相对web服务器根目录的相对路径字符串, 这个是构建时就返回了
（通过传入的路径获取到文件里的代码片段执行eval方法）

#### ES modules ####  
是javascript官方标准化模块系统  
ES6的模块输出的是值的引用，  
编译时加载，  
可以是多个，  
静态语法可以写在顶层，但是可以动态加载？？（可以异步动态import）  
this是undefined??  
语法：import和export，还有export default  
2015年6月ECMAScript2015，ES6发布，本质上是运行时解析（之前加载的时候会生成一个只读引用，等到脚本真正执行时，才会通过引用模块中获取值，如果值发生了变化，导入的地方也会跟着变化，并不会缓存值），成为浏览器和服务器的通用解决方案  

命名空间，立即执行函数，依赖注入（设计模式）  

#### cmd与amd ####  
规范	推崇	代表作
AMD	依赖前置	requirejs
CMD	依赖就近	seajs
cmd是延迟执行，as lazy as possible尽可能的懒加载，